<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="next" href="Pcache_debug.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Gom" rel="Chapter" href="Gom.html">
<link title="Pcache_debug" rel="Chapter" href="Pcache_debug.html">
<link title="Persistent_chunked_list" rel="Chapter" href="Persistent_chunked_list.html">
<link title="Persistent_list" rel="Chapter" href="Persistent_list.html">
<link title="Persistent_log" rel="Chapter" href="Persistent_log.html">
<link title="Tjr_pcache_doc" rel="Chapter" href="Tjr_pcache_doc.html"><title>Gom</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Pcache_debug.html" title="Pcache_debug">Next</a>
</div>
<h1>Module <a href="type_Gom.html">Gom</a></h1>

<pre><span id="MODULEGom"><span class="keyword">module</span> Gom</span>: <code class="code">sig</code> <a href="Gom.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<p>The Global Object Map (GOM).</p>
</div>
</div>
<hr width="100%">
<p>At a high level, this is an int -&gt; int map, from object id to
   block id (the root of the object on disk).</p>

<p>The in-memory map is maintained as in an LRU in memory. Thus, this
   implementation only has to deal with persistent aspects.</p>

<p>When the LRU becomes full, or on sync of a particular object id, the
   GOM receives a list of map operations.</p>

<p>These are written straight to the pcache.</p>

<p>At intervals, when the pcache becomes long, some initial prefix of the
   pcache is rolled into the B-tree. The root of the pcache is
   adjusted (the old blocks can be reclaimed), and the root is written
   to disk (but not necessarily synced). On crash, if the old root is
   used there is no problem - we just replay these modifications over
   the B-tree. We require that if the new pcache root hits disk, the
   B-tree is also on disk. One approach is to async (flush btree;
   flush pcache root).</p>

<pre><span id="MODULEMake_gom"><span class="keyword">module</span> <a href="Gom.Make_gom.html">Make_gom</a></span>: <div class="sig_block"><code class="code">functor (</code><code class="code">Gom_requires</code><code class="code"> : </code><code class="code">sig</code></pre><div class="sig_block">
<pre><span id="MODULEBt_blk_id"><span class="keyword">module</span> <a href="Gom.Bt_blk_id.html">Bt_blk_id</a></span>: <code class="type">Tjr_int.TYPE_ISOMORPHIC_TO_INT</code><code class="type"> </code></pre>
<pre><span id="MODULEPc_blk_id"><span class="keyword">module</span> <a href="Gom.Pc_blk_id.html">Pc_blk_id</a></span>: <code class="type">Tjr_int.TYPE_ISOMORPHIC_TO_INT</code><code class="type"> </code></pre></div><pre><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Gom.Make_gom.html">..</a> <code class="code">end</code></div></pre></body></html>