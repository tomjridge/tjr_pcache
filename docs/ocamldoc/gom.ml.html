<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>gom.ml</title>
<meta name="generator" content="emacs 25.3.1; htmlfontify 0.21" />
<style type="text/css"><!-- 
body { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.default   { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.default a { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.merlin-compilation-warning-face-0000   { color: #ff8c00;  font-weight: 700;  font-family: Ubuntu Mono;  font-stretch: normal;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.merlin-compilation-warning-face-0000 a { color: #ff8c00;  font-weight: 700;  font-family: Ubuntu Mono;  font-stretch: normal;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.constant   { color: #008b8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.constant a { color: #008b8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.keyword   { color: #a020f0;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.keyword a { color: #a020f0;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.variable-name   { color: #a0522d;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.variable-name a { color: #a0522d;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.function-name   { color: #0000ff;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.function-name a { color: #0000ff;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.type   { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.type a { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.constructor   { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.constructor a { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #000000;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.operator   { color: #a52a2a;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.operator a { color: #a52a2a;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.comment   { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.comment a { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.comment-delimiter   { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.comment-delimiter a { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.module   { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.module a { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.governing   { color: #000000;  font-weight: 700;  font-family: Ubuntu Mono;  font-stretch: normal;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.governing a { color: #000000;  font-weight: 700;  font-family: Ubuntu Mono;  font-stretch: normal;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
span.doc   { color: #8b2252;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: none; }
span.doc a { color: #8b2252;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #ffffff;  font-size: 10pt;  text-decoration: underline; }
 --></style>

    <script type="text/javascript"><!--
  // this function is needed to work around
  // a bug in IE related to element attributes
  function hasClass(obj)
  {
      var result = false;
      if (obj.getAttributeNode("class") != null)
      {
          result = obj.getAttributeNode("class").value;
      }
      return result;
  }

  function stripe(id)
  {
      // the flag we'll use to keep track of
      // whether the current row is odd or even
      var even = false;

      // if arguments are provided to specify the colors
      // of the even & odd rows, then use the them;
      // otherwise use the following defaults:
      var evenColor = arguments[1] ? arguments[1] : "#fff";
      var oddColor  = arguments[2] ? arguments[2] : "#ddd";

      // obtain a reference to the desired table
      // if no such table exists, abort
      var table = document.getElementById(id);
      if (! table) { return; }

      // by definition, tables can have more than one tbody
      // element, so we'll have to get the list of child
      // &lt;tbody&gt;s
      var tbodies = table.getElementsByTagName("tbody");

      // and iterate through them...
      for (var h = 0; h < tbodies.length; h++)
      {
          // find all the &lt;tr&gt; elements...
          var trs = tbodies[h].getElementsByTagName("tr");

          // ... and iterate through them
          for (var i = 0; i < trs.length; i++)
          {
              // avoid rows that have a class attribute
              // or backgroundColor style
              if (! hasClass(trs[i]) &&
                  ! trs[i].style.backgroundColor)
              {
                  // get all the cells in this row...
                  var tds = trs[i].getElementsByTagName("td");

                  // and iterate through them...
                  for (var j = 0; j < tds.length; j++)
                  {
                      var mytd = tds[j];

                      // avoid cells that have a class attribute
                      // or backgroundColor style
                      if (! hasClass(mytd) &&
                          ! mytd.style.backgroundColor)
                      {
                          mytd.style.backgroundColor =
                            even ? evenColor : oddColor;
                      }
                  }
              }
              // flip from odd to even, or vice-versa
              even =  ! even;
          }
      }
  }

  function toggle_invis( name )
  {
      var filter =
        { acceptNode:
          function( node )
          { var classname = node.id;
            if( classname )
            { var classbase = classname.substr( 0, name.length );
              if( classbase == name ) { return NodeFilter.FILTER_ACCEPT; } }
            return NodeFilter.FILTER_SKIP; } };
      var walker = document.createTreeWalker( document.body           ,
                                              NodeFilter.SHOW_ELEMENT ,
                                              filter                  ,
                                              false                   );
      while( walker.nextNode() )
      {
          var e = walker.currentNode;
          if( e.style.display == "none" ) { e.style.display = "inline"; }
          else                            { e.style.display = "none";   }
      }
  }
--> </script>
  </head>
  <body onload="stripe('index'); return true;">

<pre><span class="doc">(** The Global Object Map (GOM). *)</span>

<span class="doc">(** At a high level, this is an int -&gt; int map, from object id to
   block id (the root of the object on disk).

The in-memory map is maintained as in an LRU in memory. Thus, this
   implementation only has to deal with persistent aspects.

When the LRU becomes full, or on sync of a particular object id, the
   GOM receives a list of map operations.

These are written straight to the pcache.


At intervals, when the pcache becomes long, some initial prefix of the
   pcache is rolled into the B-tree. The root of the pcache is
   adjusted (the old blocks can be reclaimed), and the root is written
   to disk (but not necessarily synced). On crash, if the old root is
   used there is no problem - we just replay these modifications over
   the B-tree. We require that if the new pcache root hits disk, the
   B-tree is also on disk. One approach is to async (flush btree;
   flush pcache root).

*)</span>

<span class="governing">open </span><span class="module">Tjr_monad.Monad</span>


<span class="comment-delimiter">(*</span><span class="comment">
module type GOM_REQUIRES = sig

  (* although we deal with fixed k=obj_id and v=blk_id, we might as
     well treat these as parameters, since all the other libraries are
     parametric anyway and nothing depends on the exact nature of
     these *)

  (** The B-tree operations *)
  (* FIXME just use existing Tjr_btree.Map_ops.map_ops 
  type ('k,'v,'t) map_ops = {
    find: 'k -&gt; ('v option,'t) m;
    insert: 'k -&gt; 'v -&gt; (unit,'t) m;
    delete: 'k -&gt; (unit,'t) m;
    insert_many: 'k -&gt; 'v -&gt; ('k*'v) list -&gt; (('k*'v)list,'t) m
  }
  *)
  (* NOTE we may execute find on the B-tree if we execute GOM.find and nothing in pcache or LRU *)
  type ('k,'v,'t) map_ops = ('k,'v,'t</span><span class="comment">)</span><span class="comment"> Tjr_btree.Map_ops.map_ops</span><span class="comment">
</span><span class="comment">

  (** The pcache operations *)
  type ('k,'v,'map,'ptr,'t) plog_ops = ('k,'v,'map,'ptr,'t</span><span class="comment">)</span><span class="comment"> Persistent_log.plog_ops

  (* What API do we expose? We need to support what comes from the
     LRU, which is roughly the map operations, but likely batched. In
     fact, at the moment the LRU does not produce insert_many
     operations, but probably it should. So really we need to support
     all the map operations. *)

  (* NOTE we provide map_ops *)

  type blk_id
end
</span><span class="comment-delimiter">*)</span>


<span class="governing">module</span> <span class="module">Make_gom</span><span class="operator">(</span><span class="constructor">Gom_requires</span> <span class="operator">:</span><span class="type"> </span><span class="governing">sig</span><span class="type"> </span><span class="governing">type</span><span class="type"> blk_id </span><span class="governing">end</span><span class="operator">)</span> <span class="operator">=</span> <span class="governing">struct</span>
  
  <span class="governing">open </span><span class="module">Gom_requires</span>

  <span class="governing">open </span><span class="module">Tjr_btree.Map_ops</span>

  <span class="governing">open </span><span class="module">Persistent_log</span>

  <span class="doc">(** The gom state consists of a flag indicating that we are executing a roll-up *)</span>
  <span class="governing">type</span> <span class="type">gom_state</span> <span class="operator">=</span> <span class="operator">{</span>
    in_roll_up<span class="operator">:</span> bool<span class="operator">;</span>
    pcache_root<span class="operator">:</span> blk_id<span class="operator">;</span>
    btree_root<span class="operator">:</span> blk_id<span class="operator">;</span>
  <span class="operator">}</span>

  <span class="governing">open </span><span class="module">Tjr_monad.Mref_plus</span>

  <span class="governing">type</span> <span class="type">'t gom_state_ops</span> <span class="operator">=</span> <span class="operator">(</span>gom_state<span class="operator">,</span>'t<span class="operator">)</span> mref

  <span class="comment-delimiter">(* </span><span class="comment">we perform a &quot;roll up&quot; operation, merging the pcache into the
     B-tree, when the number of pcache blocks reaches
     pcache_blocks_limit </span><span class="comment-delimiter">*)</span>

  <span class="governing">let</span> <span class="function-name">make_gom_ops</span><span class="variable-name">
      </span><span class="operator">~</span><span class="variable-name">monad_ops </span><span class="operator">~</span><span class="variable-name">btree_ops </span><span class="operator">~</span><span class="variable-name">pcache_ops </span><span class="operator">~</span><span class="variable-name">pcache_blocks_limit</span> 
      <span class="operator">~</span>gom_mref_ops <span class="operator">~(</span>detach_map_ops<span class="operator">:(</span>'k<span class="operator">,</span>'v<span class="operator">,</span>'map<span class="operator">)</span> <span class="module">Persistent_log.</span>detach_map_ops<span class="operator">)</span> 
      <span class="operator">~</span>bt_sync  <span class="comment-delimiter">(* </span><span class="comment">to sync the btree </span><span class="comment-delimiter">*)</span>
      <span class="operator">~</span>sync_pcache_roots  <span class="comment-delimiter">(* </span><span class="comment">to write the pcache roots to disk somewhere </span><span class="comment-delimiter">*)</span>
    <span class="operator">=</span>
    <span class="governing">let</span> <span class="operator">(</span><span class="variable-name"> </span><span class="operator">&gt;&gt;=</span><span class="variable-name"> </span><span class="operator">)</span> <span class="operator">=</span> monad_ops.bind <span class="governing">in</span>
    <span class="governing">let</span> <span class="variable-name">return</span> <span class="operator">=</span> monad_ops.return <span class="governing">in</span>
    dest_map_ops btree_ops <span class="operator">@@</span> <span class="keyword">fun</span> <span class="operator">~</span><span class="variable-name">find </span><span class="operator">~</span><span class="variable-name">insert </span><span class="operator">~</span><span class="variable-name">delete </span><span class="operator">~</span><span class="variable-name">insert_many</span> <span class="operator">-&gt;</span>
    <span class="comment-delimiter">(* </span><span class="comment">rename just so we don't get confused </span><span class="comment-delimiter">*)</span>
    <span class="governing">let</span> <span class="operator">(</span><span class="variable-name">bt_find</span><span class="operator">,</span><span class="variable-name">bt_insert</span><span class="operator">,</span><span class="variable-name">bt_delete</span><span class="operator">,</span><span class="variable-name">bt_insert_many</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span>find<span class="operator">,</span>insert<span class="operator">,</span>delete<span class="operator">,</span>insert_many<span class="operator">)</span> <span class="governing">in</span>
    <span class="governing">let</span> <span class="module">Persistent_log.</span><span class="operator">{</span>find<span class="operator">;</span> add<span class="operator">;</span> detach<span class="operator">;</span> get_block_list_length<span class="operator">}</span> <span class="operator">=</span> pcache_ops <span class="governing">in</span>
    <span class="governing">let</span> <span class="operator">(</span><span class="variable-name">pc_find</span><span class="operator">,</span><span class="variable-name">pc_add</span><span class="operator">,</span><span class="variable-name">pc_detach</span><span class="operator">,</span><span class="variable-name">pc_get_block_list_length</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span>find<span class="operator">,</span>add<span class="operator">,</span>detach<span class="operator">,</span>get_block_list_length<span class="operator">)</span> <span class="governing">in</span>
    <span class="governing">let</span> <span class="function-name">find</span><span class="variable-name"> k</span> <span class="operator">=</span> 
      pc_find k <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">op</span> <span class="operator">-&gt;</span>
      <span class="keyword">match</span> op <span class="keyword">with</span>
      <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> bt_find k
      <span class="operator">|</span> <span class="constructor">Some</span> op <span class="operator">-&gt;</span>
        <span class="keyword">match</span> op <span class="keyword">with</span>
        <span class="operator">|</span> <span class="constructor">Insert</span><span class="operator">(</span>k<span class="operator">,</span>v<span class="operator">)</span> <span class="operator">-&gt;</span> return <span class="operator">(</span><span class="constructor">Some</span> v<span class="operator">)</span>
        <span class="operator">|</span> <span class="constructor">Delete</span> k <span class="operator">-&gt;</span> return <span class="constructor">None</span>
    <span class="governing">in</span>
    <span class="governing">let</span> <span class="function-name">maybe_roll_up</span><span class="variable-name"> </span><span class="operator">()</span> <span class="operator">=</span> 
      gom_mref_ops.get <span class="operator">()</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">function</span> <span class="operator">{</span> in_roll_up <span class="operator">}</span> <span class="operator">-&gt;</span>
        <span class="keyword">match</span> in_roll_up <span class="keyword">with</span>
        <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> 
          return <span class="constructor">`Already_in_roll_up</span>
        <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span>
          pc_get_block_list_length <span class="operator">()</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">n</span> <span class="operator">-&gt;</span>
          <span class="keyword">match</span> n <span class="operator">&gt;=</span> pcache_blocks_limit <span class="keyword">with</span>
          <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> return <span class="constructor">`No_roll_up_needed</span>
          <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> 
            <span class="comment-delimiter">(* </span><span class="comment">we need to roll-up the pcache into the B-tree </span><span class="comment-delimiter">*)</span>
            <span class="comment-delimiter">(* </span><span class="comment">first set the flag; if already set, just skip the roll
               up since someone else is doing it </span><span class="comment-delimiter">*)</span>
            gom_mref_ops.with_ref <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span> 
                <span class="keyword">match</span> s.in_roll_up <span class="keyword">with</span>
                <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> <span class="constructor">`Already_in_roll_up</span><span class="operator">,</span>s
                <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> <span class="constructor">`Ok</span><span class="operator">,{</span>s <span class="keyword">with</span> in_roll_up<span class="operator">=</span><span class="constant">true</span><span class="operator">})</span> <span class="operator">&gt;&gt;=</span> 
            <span class="governing">begin</span>
              <span class="keyword">function</span>
              <span class="operator">|</span> <span class="constructor">`Already_in_roll_up</span> <span class="operator">-&gt;</span>
                <span class="comment-delimiter">(* </span><span class="comment">of course, we checked in_roll_up above, and it was
                   false; but a concurrent thread may have set it in the
                   meantime </span><span class="comment-delimiter">*)</span>
                return <span class="constructor">`Already_in_roll_up</span>
              <span class="operator">|</span> <span class="constructor">`Ok</span> <span class="operator">-&gt;</span> 
                <span class="comment-delimiter">(* </span><span class="comment">the flag has been set; we need to roll up the cache;
                   FIXME we also need some sort of
                   backpressure/prioritization on this roll-up thread in
                   case the cache is running too far ahead of the B-tree </span><span class="comment-delimiter">*)</span>
                pc_detach <span class="operator">()</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">old_root</span><span class="operator">,(</span><span class="variable-name">map</span><span class="operator">:</span><span class="type">'map</span><span class="operator">),</span><span class="variable-name">new_root</span><span class="operator">)</span> <span class="operator">-&gt;</span>
                <span class="comment-delimiter">(* </span><span class="comment">map consists of all the entries we need to roll up </span><span class="comment-delimiter">*)</span>
                map <span class="operator">|&gt;</span> detach_map_ops.<span class="merlin-compilation-warning-face-0000">map_bindings</span> <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">kvs</span> <span class="operator">-&gt;</span>
                <span class="governing">let</span> <span class="governing">rec</span> <span class="function-name">loop</span><span class="variable-name"> kvs</span> <span class="operator">=</span> 
                  <span class="keyword">match</span> kvs <span class="keyword">with</span>
                  <span class="operator">|</span> <span class="operator">[]</span> <span class="operator">-&gt;</span> return  <span class="operator">(</span><span class="constructor">`Finished</span><span class="operator">(</span>old_root<span class="operator">,</span>new_root<span class="operator">))</span>
                  <span class="operator">|</span> <span class="operator">(</span>k<span class="operator">,</span>v<span class="operator">)::</span>kvs <span class="operator">-&gt;</span>
                    <span class="keyword">match</span> v <span class="keyword">with</span>
                    <span class="operator">|</span> <span class="constructor">Insert</span> <span class="operator">(</span>k<span class="operator">,</span>v<span class="operator">)</span> <span class="operator">-&gt;</span> bt_insert k v <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span> loop kvs
                    <span class="operator">|</span> <span class="constructor">Delete</span> k <span class="operator">-&gt;</span> bt_delete k <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span> loop kvs
                <span class="governing">in</span>
                loop kvs
            <span class="governing">end</span>
            <span class="operator">&gt;&gt;=</span> 
            <span class="governing">begin</span>
              <span class="keyword">function</span>
              <span class="operator">|</span> <span class="constructor">`Already_in_roll_up</span> <span class="operator">-&gt;</span> return <span class="constructor">`Already_in_roll_up</span>
              <span class="operator">|</span> <span class="constructor">`Finished</span><span class="operator">(</span>old_root<span class="operator">,</span><span class="comment-delimiter">(*</span><span class="comment">new</span><span class="comment-delimiter">*)</span>pcache_root<span class="operator">)</span> <span class="operator">-&gt;</span> 
                <span class="comment-delimiter">(* </span><span class="comment">sync the btree </span><span class="comment-delimiter">*)</span>
                <span class="comment-delimiter">(* </span><span class="comment">NOTE this should be done in the critical section, before resetting the flag </span><span class="comment-delimiter">*)</span>
                bt_sync <span class="operator">()</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">btree_root</span> <span class="operator">-&gt;</span>
                <span class="comment-delimiter">(* </span><span class="comment">now we need to reset the flag, and the roots </span><span class="comment-delimiter">*)</span>
                sync_pcache_roots <span class="operator">~</span>btree_root <span class="operator">~</span>pcache_root <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span>
                gom_mref_ops.with_ref <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span> 
                    <span class="keyword">assert</span><span class="operator">(</span>s.in_roll_up<span class="operator">);</span>
                    <span class="operator">(),{</span> in_roll_up<span class="operator">=</span><span class="constant">false</span><span class="operator">;</span> btree_root<span class="operator">;</span> pcache_root <span class="operator">})</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span>
                return <span class="constructor">`Ok</span>
            <span class="governing">end</span>              
    <span class="governing">in</span>
    <span class="governing">let</span> <span class="function-name">insert</span><span class="variable-name"> k v</span> <span class="operator">=</span>
      pc_add <span class="operator">(</span><span class="constructor">Insert</span><span class="operator">(</span>k<span class="operator">,</span>v<span class="operator">))</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span> 
      maybe_roll_up <span class="operator">()</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
      return <span class="operator">()</span>
    <span class="governing">in</span>
    <span class="governing">let</span> <span class="function-name">delete</span><span class="variable-name"> k</span> <span class="operator">=</span>
      pc_add <span class="operator">(</span><span class="constructor">Delete</span> k<span class="operator">)</span>
    <span class="governing">in</span>
    <span class="governing">let</span> <span class="function-name">insert_many</span><span class="variable-name"> k v kvs</span> <span class="operator">=</span> 
      <span class="comment-delimiter">(* </span><span class="comment">FIXME we should do something smarter here </span><span class="comment-delimiter">*)</span>
      insert k v <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span> return kvs
    <span class="governing">in</span>
    <span class="operator">{</span> find<span class="operator">;</span> insert<span class="operator">;</span> delete<span class="operator">;</span> insert_many <span class="operator">}</span>
    

  <span class="comment-delimiter">(* </span><span class="comment">FIXME when we detach, we should not alter the pcache root, but
     later after the btree changes are synced, we can sync the new
     pcache root; or perhaps we store both roots somewhere else - in
     the gom controller </span><span class="comment-delimiter">*)</span>

<span class="governing">end</span>
</pre>

 </body>
</html>
