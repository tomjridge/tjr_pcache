<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dcl_types (tjr_pcache.Tjr_pcache__.Pcache_intf.Dcl_types)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">tjr_pcache</a> &#x00BB; <a href="../../index.html">Tjr_pcache__</a> &#x00BB; <a href="../index.html">Pcache_intf</a> &#x00BB; Dcl_types</nav><h1>Module <code>Pcache_intf.Dcl_types</code></h1></header><aside><p>The DCL types</p></aside><dl><dt class="spec type" id="type-abs_ops"><a href="#type-abs_ops" class="anchor"></a><code><span class="keyword">type</span> ('op, 'abs) abs_ops</code><code> = </code><code>{</code><table class="record"><tr id="type-abs_ops.empty" class="anchored"><td class="def field"><a href="#type-abs_ops.empty" class="anchor"></a><code>empty : <span class="type-var">'abs</span>;</code></td></tr><tr id="type-abs_ops.add" class="anchored"><td class="def field"><a href="#type-abs_ops.add" class="anchor"></a><code>add : <span class="type-var">'op</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span>;</code></td></tr><tr id="type-abs_ops.merge" class="anchored"><td class="def field"><a href="#type-abs_ops.merge" class="anchor"></a><code>merge : <span class="type-var">'abs</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span>;</code></td></tr></table><code>}</code></dt><dd><p>Operations on the &quot;abstract&quot; state. The pcl state is something like a list of map operations. The 'abs type is something like the &quot;map&quot; view of these operations (needed because the list is redundant, or at the very least inefficient for map operations). Type vars:</p><ul><li><code>'op</code> is eg insert(k,v), delete(k)</li><li>'abs is the &quot;abstraction&quot;</li></ul><p>Operations:</p><ul><li>empty, the empty map</li><li>add, to add an operation to the abstract state</li><li>merge, to merge two maps (second takes precedence); used when a new node is created, and the old node is merged into the accumulated past nodes.</li></ul></dd></dl><dl><dt class="spec value" id="val-abs_singleton"><a href="#val-abs_singleton" class="anchor"></a><code><span class="keyword">val</span> abs_singleton : abs_ops:(<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-abs_ops">abs_ops</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt></dl><dl><dt class="spec type" id="type-dcl_state"><a href="#type-dcl_state" class="anchor"></a><code><span class="keyword">type</span> ('ptr, 'abs) dcl_state</code><code> = </code><code>{</code><table class="record"><tr id="type-dcl_state.start_block" class="anchored"><td class="def field"><a href="#type-dcl_state.start_block" class="anchor"></a><code>start_block : <span class="type-var">'ptr</span>;</code></td></tr><tr id="type-dcl_state.current_block" class="anchored"><td class="def field"><a href="#type-dcl_state.current_block" class="anchor"></a><code>current_block : <span class="type-var">'ptr</span>;</code></td></tr><tr id="type-dcl_state.block_list_length" class="anchored"><td class="def field"><a href="#type-dcl_state.block_list_length" class="anchor"></a><code>block_list_length : int;</code></td></tr><tr id="type-dcl_state.abs_past" class="anchored"><td class="def field"><a href="#type-dcl_state.abs_past" class="anchor"></a><code>abs_past : <span class="type-var">'abs</span>;</code></td></tr><tr id="type-dcl_state.abs_current" class="anchored"><td class="def field"><a href="#type-dcl_state.abs_current" class="anchor"></a><code>abs_current : <span class="type-var">'abs</span>;</code></td></tr></table><code>}</code></dt><dd><p>The state of the DCL. Fields are:</p><ul><li><code>start_block</code> is the root of the log</li><li><code>current_block</code> is the current block being written to</li><li><code>abs_past</code> is the abstract view of ops from root to just before <code>current_block</code></li><li><code>abs_current</code> is the abstract view of ops for the current block</li></ul><p>NOTE unlike Pl and Pcl, we have a concrete type for the state, since we don't expect to have any extra info stored at this point. (FIXME what about dcl_dummy_implementation where we need to store all ptrs?) But perhaps we can avoid some of these extra type params if we keep dcl state abstract as <code>'dcl_state</code>. But this seems unlikely.</p><p>NOTE <code>block_list_length</code>: this is the number of blocks from the underlying chunked list, used to store the ops (not the abstract representation!)</p><p>NOTE upto this point, the pl and the pcl have not explicitly tracked the start of the list. FIXME perhaps they should? This has advantages in that the abstraction is self-contained.</p></dd></dl><dl><dt class="spec type" id="type-dcl_ops"><a href="#type-dcl_ops" class="anchor"></a><code><span class="keyword">type</span> ('op, 'abs, 'ptr, 't) dcl_ops</code><code> = </code><code>{</code><table class="record"><tr id="type-dcl_ops.add" class="anchored"><td class="def field"><a href="#type-dcl_ops.add" class="anchor"></a><code>add : <span class="type-var">'op</span> <span>&#45;&gt;</span> (unit, <span class="type-var">'t</span>) Tjr_monad.m;</code></td></tr><tr id="type-dcl_ops.peek" class="anchored"><td class="def field"><a href="#type-dcl_ops.peek" class="anchor"></a><code>peek : unit <span>&#45;&gt;</span> ((<span class="type-var">'ptr</span>, <span class="type-var">'abs</span>) <a href="index.html#type-dcl_state">dcl_state</a>, <span class="type-var">'t</span>) Tjr_monad.m;</code></td></tr><tr id="type-dcl_ops.detach" class="anchored"><td class="def field"><a href="#type-dcl_ops.detach" class="anchor"></a><code>detach : unit <span>&#45;&gt;</span> ((<span class="type-var">'ptr</span>, <span class="type-var">'abs</span>) <a href="index.html#type-dcl_state">dcl_state</a>, <span class="type-var">'t</span>) Tjr_monad.m;</code></td></tr><tr id="type-dcl_ops.block_list_length" class="anchored"><td class="def field"><a href="#type-dcl_ops.block_list_length" class="anchor"></a><code>block_list_length : unit <span>&#45;&gt;</span> (int, <span class="type-var">'t</span>) Tjr_monad.m;</code></td></tr></table><code>}</code></dt><dd><p>The DCL ops:</p><ul><li><code>add</code> to add an op</li><li><code>peek</code> to reveal the dcl_state (FIXME why?)</li><li><code>detach</code> to issue a detach operation (eg prior to rolling the past entries into a B-tree)</li><li><code>block_list_length</code> to provide information to help determine when to roll up</li></ul><p>The <code>detach</code> operation means that we should start a new cache from the current block.</p><p>The return result is the ptr and map corresponding to the contents of everything up to the current block, and the ptr and map for the current block. The intention is that the detached part is then rolled into the B-tree. If we only have 1 block, then nothing is rolled up. This occurs when <code>old_ptr</code> is the same as <code>new_ptr</code> FIXME use a new type</p><p>NOTE detach returns the dcl_state since this includes at least all the fields we need.</p></dd></dl></div></body></html>