<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Internal_collection_of_all_types (tjr_pcache.Tjr_pcache__.Pcache_intf.Internal_collection_of_all_types)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">tjr_pcache</a> &#x00BB; <a href="../../index.html">Tjr_pcache__</a> &#x00BB; <a href="../index.html">Pcache_intf</a> &#x00BB; Internal_collection_of_all_types</nav><h1>Module <code>Pcache_intf.Internal_collection_of_all_types</code></h1></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-Map_ops">Map_ops</a></code></span></summary><dl><dt class="spec type" id="type-map_ops"><a href="#type-map_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'v, 't) map_ops</span></code><code> = </code><code>{</code><table class="record"><tr id="type-map_ops.find" class="anchored"><td class="def field"><a href="#type-map_ops.find" class="anchor"></a><code>find : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'v</span> option</span>, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-map_ops.insert" class="anchored"><td class="def field"><a href="#type-map_ops.insert" class="anchor"></a><code>insert : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-map_ops.delete" class="anchored"><td class="def field"><a href="#type-map_ops.delete" class="anchor"></a><code>delete : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr></table><code>}</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-Pl_types">Pl_types</a></code></span></summary><aside><p>A persistent list maintains a state, iso to a pair of (data,next_ptr option). It knows nothing about the data (especially, it does not know the marshalled size of the data). It allows to set the &quot;current&quot; data (possibly many times), to step to a new node (a node corresponds to a block), and to issue a write to disk.</p></aside><dl><dt class="spec type" id="type-pl_state_ops"><a href="#type-pl_state_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'ptr, 'i) pl_state_ops</span></code><code> = </code><code>{</code><table class="record"><tr id="type-pl_state_ops.set_data" class="anchored"><td class="def field"><a href="#type-pl_state_ops.set_data" class="anchor"></a><code>set_data : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'i</span>;</code></td></tr><tr id="type-pl_state_ops.set_next" class="anchored"><td class="def field"><a href="#type-pl_state_ops.set_next" class="anchor"></a><code>set_next : <span class="type-var">'ptr</span> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'i</span>;</code></td></tr><tr id="type-pl_state_ops.new_node" class="anchored"><td class="def field"><a href="#type-pl_state_ops.new_node" class="anchor"></a><code>new_node : <span class="type-var">'ptr</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'i</span>;</code></td></tr></table><code>}</code></dt><dd><p>The persistent list state. Each node consists of data and a possible next pointer (initially None, but may be set subsequently). For <code>new_node</code>, the ptr is the ptr of the new block, the second argument is the data, and the third is the internal repr. of the current node.</p><p>NOTE the type <code>'a</code> is the type of the data stored in each node.</p><p>Type variables:</p><ul><li><code>'a</code> the type of data stored in pl nodes</li><li><code>'ptr</code> the type of pointers to nodes; each node has an optional next pointer</li><li><code>'i</code> the internal state of the persistent list FIXME rename?</li></ul><p>NOTE the module <a href="../../Simple_pl_and_pcl_implementations/index.html"><code>Simple_pl_and_pcl_implementations</code></a> contains the obvious implementation of this type.</p></dd></dl><dl><dt class="spec type" id="type-pl_ops"><a href="#type-pl_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'ptr, 't) pl_ops</span></code><code> = </code><code>{</code><table class="record"><tr id="type-pl_ops.replace_last" class="anchored"><td class="def field"><a href="#type-pl_ops.replace_last" class="anchor"></a><code>replace_last : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-pl_ops.new_node" class="anchored"><td class="def field"><a href="#type-pl_ops.new_node" class="anchor"></a><code>new_node : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'ptr</span>, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-pl_ops.pl_write" class="anchored"><td class="def field"><a href="#type-pl_ops.pl_write" class="anchor"></a><code>pl_write : unit <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-pl_ops.pl_sync" class="anchored"><td class="def field"><a href="#type-pl_ops.pl_sync" class="anchor"></a><code>pl_sync : unit <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr></table><code>}</code></dt><dd><p>The operations provided by the persistent list.</p><ul><li><code>replace_last</code> replaces the contents of the last element of the list.</li><li><code>new_node</code> allocates a new node at the end of the list and makes it the &quot;current&quot; node.</li><li><code>pl_write</code> issues a disk write for hte current node</li><li><code>pl_sync</code> force a write to disk; a disk write happens automatically when allocating a new node; this forces a possibly-partial node to disk</li></ul></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-Pcl_types">Pcl_types</a></code></span></summary><aside><p>A persistent chunked list interface. The state consists of something of type <code>'i</code> isomorphic to a list of elements. There is a function to convert the list to pl-format data. The cons list operation &quot;knows&quot; something about the marshalled size of the list, and can indicate when the size of the list has become larger than the backing node/block can handle.</p></aside><dl><dt class="spec type" id="type-pcl_state_ops"><a href="#type-pcl_state_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('pl_data, 'e, 'i) pcl_state_ops</span></code><code> = </code><code>{</code><table class="record"><tr id="type-pcl_state_ops.nil" class="anchored"><td class="def field"><a href="#type-pcl_state_ops.nil" class="anchor"></a><code>nil : unit <span>&#45;&gt;</span> <span class="type-var">'i</span>;</code></td></tr><tr id="type-pcl_state_ops.snoc" class="anchored"><td class="def field"><a href="#type-pcl_state_ops.snoc" class="anchor"></a><code>snoc : <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'e</span> <span>&#45;&gt;</span> <span>[ `Error_too_large <span><span>| `Ok</span> of <span class="type-var">'i</span></span> ]</span>;</code></td></tr><tr id="type-pcl_state_ops.pl_data" class="anchored"><td class="def field"><a href="#type-pcl_state_ops.pl_data" class="anchor"></a><code>pl_data : <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'pl_data</span>;</code></td></tr></table><code>}</code></dt><dd><p>Pure interface for manipulating the <code>pcl_state</code>. Type vars:</p><ul><li><code>'i</code> the internal pcl state type (kept abstract)</li><li><code>'e</code> the non-marshalled element type</li><li><code>'pl_data</code> the type of data stored in a persistent list node (there is also a pointer in the pl node)</li></ul><p>Functions:</p><ul><li><code>nil</code> the empty state corresponding to a new node created when the old node is full; use pl_data to get the underlying pl_node</li><li><code>snoc</code> to add an element</li><li><code>pl_data</code> to project from the pcl state to the actual data to be written (using pl)</li></ul><p>NOTE that the &quot;next&quot; pointer manipulation has been confined to the persistent list interface.</p></dd></dl><aside><p>NOTE that if we store the list of e in the pcl_state, then pl_data potentially repeatedly marshals the prefix of the list that was marshalled last time; to avoid this, pcl likely stores the marshalled version of the e list, which is passed directly to pl (which then adds the next ptr). See the dmap_example in package tjr_pcache_example for an example.</p></aside><dl><dt class="spec type" id="type-inserted_type"><a href="#type-inserted_type" class="anchor"></a><code><span class="keyword">type</span> <span>'ptr inserted_type</span></code><code> = </code><table class="variant"><tr id="type-inserted_type.Inserted_in_current_node" class="anchored"><td class="def constructor"><a href="#type-inserted_type.Inserted_in_current_node" class="anchor"></a><code>| </code><code><span class="constructor">Inserted_in_current_node</span></code></td></tr><tr id="type-inserted_type.Inserted_in_new_node" class="anchored"><td class="def constructor"><a href="#type-inserted_type.Inserted_in_new_node" class="anchor"></a><code>| </code><code><span class="constructor">Inserted_in_new_node</span> <span class="keyword">of</span> <span class="type-var">'ptr</span></code></td></tr></table></dt><dd><p>A type that records whether an element was inserted in the current node, or whether a new node was allocated to hold the element.</p></dd></dl><dl><dt class="spec type" id="type-pcl_ops"><a href="#type-pcl_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('e, 'ptr, 't) pcl_ops</span></code><code> = </code><code>{</code><table class="record"><tr id="type-pcl_ops.insert" class="anchored"><td class="def field"><a href="#type-pcl_ops.insert" class="anchor"></a><code>insert : <span class="type-var">'e</span> <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'ptr</span> <a href="index.html#type-inserted_type">inserted_type</a></span>, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-pcl_ops.pcl_write" class="anchored"><td class="def field"><a href="#type-pcl_ops.pcl_write" class="anchor"></a><code>pcl_write : unit <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-pcl_ops.pcl_sync" class="anchored"><td class="def field"><a href="#type-pcl_ops.pcl_sync" class="anchor"></a><code>pcl_sync : unit <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr></table><code>}</code></dt><dd><p>The interface exposed by the persistent chunked list, a single <code>insert</code> function. NOTE how 'pl_data and 'i have disappeared.</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-Dcl_types">Dcl_types</a></code></span></summary><aside><p>A &quot;detachable chunked list&quot;. This is like the persistent chunked list, except that we provide a &quot;detach&quot; operation which drops the tail of the list.</p></aside><dl><dt class="spec type" id="type-abs_ops"><a href="#type-abs_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('op, 'abs) abs_ops</span></code><code> = </code><code>{</code><table class="record"><tr id="type-abs_ops.empty" class="anchored"><td class="def field"><a href="#type-abs_ops.empty" class="anchor"></a><code>empty : <span class="type-var">'abs</span>;</code></td></tr><tr id="type-abs_ops.add" class="anchored"><td class="def field"><a href="#type-abs_ops.add" class="anchor"></a><code>add : <span class="type-var">'op</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span>;</code></td></tr><tr id="type-abs_ops.merge" class="anchored"><td class="def field"><a href="#type-abs_ops.merge" class="anchor"></a><code>merge : <span class="type-var">'abs</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span>;</code></td></tr></table><code>}</code></dt><dd><p>Operations on the &quot;abstract&quot; state. The pcl state is something like a list of map operations. The 'abs type is something like the &quot;map&quot; view of these operations (needed because the list is redundant, or at the very least inefficient for map operations). Type vars:</p><ul><li><code>'op</code> is eg insert(k,v), delete(k) - 'abs is the &quot;abstraction&quot;</li></ul><p>Operations:</p><ul><li>empty, the empty map</li></ul><ul><li>add, to add an operation to the abstract state</li></ul><ul><li>merge, to merge two maps (second takes precedence); used when a new node is created, and the old node is merged into the accumulated past nodes.</li></ul></dd></dl><dl><dt class="spec value" id="val-abs_singleton"><a href="#val-abs_singleton" class="anchor"></a><code><span class="keyword">val</span> abs_singleton : <span>abs_ops:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-abs_ops">abs_ops</a></span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt></dl><dl><dt class="spec type" id="type-dcl_state"><a href="#type-dcl_state" class="anchor"></a><code><span class="keyword">type</span> <span>('ptr, 'abs) dcl_state</span></code><code> = </code><code>{</code><table class="record"><tr id="type-dcl_state.start_block" class="anchored"><td class="def field"><a href="#type-dcl_state.start_block" class="anchor"></a><code>start_block : <span class="type-var">'ptr</span>;</code></td></tr><tr id="type-dcl_state.current_block" class="anchored"><td class="def field"><a href="#type-dcl_state.current_block" class="anchor"></a><code>current_block : <span class="type-var">'ptr</span>;</code></td></tr><tr id="type-dcl_state.block_list_length" class="anchored"><td class="def field"><a href="#type-dcl_state.block_list_length" class="anchor"></a><code>block_list_length : int;</code></td></tr><tr id="type-dcl_state.abs_past" class="anchored"><td class="def field"><a href="#type-dcl_state.abs_past" class="anchor"></a><code>abs_past : <span class="type-var">'abs</span>;</code></td></tr><tr id="type-dcl_state.abs_current" class="anchored"><td class="def field"><a href="#type-dcl_state.abs_current" class="anchor"></a><code>abs_current : <span class="type-var">'abs</span>;</code></td></tr></table><code>}</code></dt><dd><p>The state of the DCL. Fields are:</p><ul><li><code>start_block</code> is the root of the log</li><li><code>current_block</code> is the current block being written to</li><li><code>abs_past</code> is the abstract view of ops from root to just before <code>current_block</code></li><li><code>abs_current</code> is the abstract view of ops for the current block</li></ul><p>NOTE unlike Pl and Pcl, we have a concrete type for the state, since we don't expect to have any extra info stored at this point. (FIXME what about dcl_dummy_implementation where we need to store all ptrs?) But perhaps we can avoid some of these extra type params if we keep dcl state abstract as <code>'dcl_state</code>. But this seems unlikely.</p><p>NOTE <code>block_list_length</code>: this is the number of blocks from the underlying chunked list, used to store the ops (not the abstract representation!)</p><p>NOTE upto this point, the pl and the pcl have not explicitly tracked the start of the list. FIXME perhaps they should? This has advantages in that the abstraction is self-contained.</p></dd></dl><dl><dt class="spec type" id="type-dcl_ops"><a href="#type-dcl_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('op, 'abs, 'ptr, 't) dcl_ops</span></code><code> = </code><code>{</code><table class="record"><tr id="type-dcl_ops.add" class="anchored"><td class="def field"><a href="#type-dcl_ops.add" class="anchor"></a><code>add : <span class="type-var">'op</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dcl_ops.peek" class="anchored"><td class="def field"><a href="#type-dcl_ops.peek" class="anchor"></a><code>peek : unit <span>&#45;&gt;</span> <span><span>(<span><span>(<span class="type-var">'ptr</span>, <span class="type-var">'abs</span>)</span> <a href="index.html#type-dcl_state">dcl_state</a></span>, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dcl_ops.detach" class="anchored"><td class="def field"><a href="#type-dcl_ops.detach" class="anchor"></a><code>detach : unit <span>&#45;&gt;</span> <span><span>(<span><span>(<span class="type-var">'ptr</span>, <span class="type-var">'abs</span>)</span> <a href="index.html#type-dcl_state">dcl_state</a></span>, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dcl_ops.block_list_length" class="anchored"><td class="def field"><a href="#type-dcl_ops.block_list_length" class="anchor"></a><code>block_list_length : unit <span>&#45;&gt;</span> <span><span>(int, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dcl_ops.dcl_write" class="anchored"><td class="def field"><a href="#type-dcl_ops.dcl_write" class="anchor"></a><code>dcl_write : unit <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dcl_ops.dcl_sync" class="anchored"><td class="def field"><a href="#type-dcl_ops.dcl_sync" class="anchor"></a><code>dcl_sync : unit <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr></table><code>}</code></dt><dd><p>The DCL operations:</p><ul><li><code>add</code> to add an op; does not necessarily write to disk</li><li><code>peek</code> to reveal the dcl_state (FIXME why?)</li><li><code>detach</code> to issue a detach operation (eg prior to rolling the past entries into a B-tree)</li><li><code>block_list_length</code> to provide information to help determine when to roll up</li></ul><p>The <code>detach</code> operation means that we should start a new cache from the current block.</p><p>The return result is the ptr and map corresponding to the contents of everything up to the current block, and the ptr and map for the current block. The intention is that the detached part is then rolled into the B-tree. If we only have 1 block, then nothing is rolled up. This occurs when <code>old_ptr</code> is the same as <code>new_ptr</code> FIXME use a new type</p><p>NOTE detach returns the dcl_state since this includes at least all the fields we need.</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../index.html#module-Dmap_types">Dmap_types</a></code></span></summary><aside><p>A dmap is effectively just a DCL with a refined 'op type and 'abs type. However, we also include functionality to convert to a standard map interface (not one based on ops).</p></aside><dl><dt class="spec type" id="type-op_map"><a href="#type-op_map" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'v) op_map</span></code><code> = <span><span>(<span class="type-var">'k</span>, <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>)</span> <a href="../index.html#type-op">op</a></span>, unit)</span> Tjr_lib.Tjr_map.map</span></code></dt><dd><p>Abbreviation; FIXME move to Ins_del_op_type</p></dd></dl><dl><dt class="spec type" id="type-dmap_state"><a href="#type-dmap_state" class="anchor"></a><code><span class="keyword">type</span> <span>('ptr, 'k, 'v) dmap_state</span></code><code> = <span><span>(<span class="type-var">'ptr</span>, <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-op_map">op_map</a></span>)</span> <a href="../Dcl_types/index.html#type-dcl_state">Dcl_types.dcl_state</a></span></code></dt><dd><p>NOTE dmap_state is just an abbreviation for dcl_state</p></dd></dl><dl><dt class="spec type" id="type-dmap_dcl_ops"><a href="#type-dmap_dcl_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('ptr, 'k, 'v, 't) dmap_dcl_ops</span></code><code> = <span><span>(<span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>)</span> <a href="../index.html#type-op">op</a></span>, <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-op_map">op_map</a></span>, <span class="type-var">'ptr</span>, <span class="type-var">'t</span>)</span> <a href="../Dcl_types/index.html#type-dcl_ops">Dcl_types.dcl_ops</a></span></code></dt><dd><p>NOTE dmap_dcl_ops is just an abbreviation for dcl_ops with:</p><ul><li>'op the type of kv op</li><li>'abs the type of kv op_map</li></ul></dd></dl><dl><dt class="spec type" id="type-detach_info"><a href="#type-detach_info" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'v, 'ptr) detach_info</span></code><code> = </code><code>{</code><table class="record"><tr id="type-detach_info.past_map" class="anchored"><td class="def field"><a href="#type-detach_info.past_map" class="anchor"></a><code>past_map : <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-op_map">op_map</a></span>;</code></td></tr><tr id="type-detach_info.current_map" class="anchored"><td class="def field"><a href="#type-detach_info.current_map" class="anchor"></a><code>current_map : <span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-op_map">op_map</a></span>;</code></td></tr><tr id="type-detach_info.current_ptr" class="anchored"><td class="def field"><a href="#type-detach_info.current_ptr" class="anchor"></a><code>current_ptr : <span class="type-var">'ptr</span>;</code></td></tr></table><code>}</code></dt><dd><p>The result of &quot;detaching&quot; the map. We get the abstract map for all but the current node, and information about the current node. FIXME could be part of dcl_ops</p></dd></dl><dl><dt class="spec type" id="type-dmap_ops"><a href="#type-dmap_ops" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'v, 'ptr, 't) dmap_ops</span></code><code> = </code><code>{</code><table class="record"><tr id="type-dmap_ops.find" class="anchored"><td class="def field"><a href="#type-dmap_ops.find" class="anchor"></a><code>find : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'v</span> option</span>, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dmap_ops.insert" class="anchored"><td class="def field"><a href="#type-dmap_ops.insert" class="anchor"></a><code>insert : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dmap_ops.delete" class="anchored"><td class="def field"><a href="#type-dmap_ops.delete" class="anchor"></a><code>delete : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dmap_ops.detach" class="anchored"><td class="def field"><a href="#type-dmap_ops.detach" class="anchor"></a><code>detach : unit <span>&#45;&gt;</span> <span><span>(<span><span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'ptr</span>)</span> <a href="index.html#type-detach_info">detach_info</a></span>, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dmap_ops.block_list_length" class="anchored"><td class="def field"><a href="#type-dmap_ops.block_list_length" class="anchor"></a><code>block_list_length : unit <span>&#45;&gt;</span> <span><span>(int, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dmap_ops.dmap_write" class="anchored"><td class="def field"><a href="#type-dmap_ops.dmap_write" class="anchor"></a><code>dmap_write : unit <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr><tr id="type-dmap_ops.dmap_sync" class="anchored"><td class="def field"><a href="#type-dmap_ops.dmap_sync" class="anchor"></a><code>dmap_sync : unit <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'t</span>)</span> Tjr_monad.m</span>;</code></td></tr></table><code>}</code></dt><dd><p>For the detach operation, we get the map upto the current node, and the map for the current node</p></dd></dl></details></div></div></div></div></body></html>